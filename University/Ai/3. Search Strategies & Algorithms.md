Different problems give rise to search spaces with particular characteristics, which may help or hinder search algorithms:
- Branching Factor: The number (or average number) of successors of each node
- State space may be finite or infinite
- Paths through the space may or may not have loops
- Maximum path length may be bounded or unbounded 
<h4>Properties Of Search Algorithms</h4>
- Completeness - Is the algorithm guaranteed to find a solution if one exists (given sufficient computational resources)
- Time Complexity - How much time does the algorithm require in relation to the depth of the solution
- Space Requirements - How much memory does the algorithm require in relation to the depth of the solution
- Optimality - Is the algorithm guaranteed to find the best solution
<h4>Implementation Techniques</h4>
- Explicit representation of node set and implementation of choice algorithm for node expansion
- Recursive Algorithm. In recursive algorithm approach the nodes not represented explicitly but are explicit in the execution sequence of the algorithm.

All standard search algorithms treat the search space as a tree.

Each node in the tree corresponds to a state.

Each node (except root) has a parent and 0 or more children. Children are nodes that are reachable by one action.

Node expansion is the process of computing the children of a given node.
Often done in 2 stages:
1. Determine what actions are possible
2. Determine the successor state that results from each of these actions
<h4>The Fringe</h4>
The **fringe** is a set of nodes that have been generated by the search procedure, but not been expanded.
The **search strategy** can be characterised as the method by which an algorithm chooses which of the fringe nodes to expand.
When a node is expanded it is no longer part of the fringe. But its children are then added to the fringe.

One way to control the way fringe nodes are chosen for expansion is to organise the fringe nodes as a **queue**. Search using a queueing system proceeds according to the following repeated sequence: 
- Take first node from the queue
- If node satisfies goal, return node (search successful)
- Otherwise, expand node to find children
- Add children to queue
If queue becomes empty, search fails.

Strategies: 

Depth First:
- Often used with loop checking and/or random branch choice.
- Modifications include: 
	- Depth Limited
	- Iterative Deepening
Breadth First:
- Can be combined with removal of duplicate states and other node pruning techniques
- Modifications include:
	- Uniform cost (not exactly breadth-first)
	- Bi-Directional Search

<h4>Properties of Depth-First Search</h4>
- Relatively modest memory requirements (‚àù path length to solution). Only need to store nodes in a single active branch
- Not usually optimal - often explores branches that are much longer than the shortest to the solution
- Not complete unless all paths terminate
- Loop checking is often required to eliminate useless infinitely repeating branches
- Can be implemented by a LIFO Node-Queueing System - i.e. Add generated child nodes to **front** of queue
<h4>Properties of Breadth-First Search</h4>
- Complete as long as branching factor is finite
- Finds optimal path first, provided that path cost is a monotonically increasing function of depth
- Execution time increases exponentially as the minimum path length to a solution increases
- Memory requirements can be very large. Need to store whole tree down to level of the solution, so memory exponential function of minimum path length to solution
- Can be implemented by a FIFO Node-Queueing System - i.e. Add generated child nodes to the **end** of queue
<h4>Depth-Limited Search</h4>
Major problem with depth-first search is that it's **incomplete** unless every branch eventually terminated either by: reaching goal or dead end, looping to a state that occurs earlier in the branch. 
If there are non-terminating branches, search may run forever without either reaching goal state or determining that the problem is insolvable.
In a depth-limited search set maximum length of path that will be searched.
Depth-limited Search still usually incomplete (unless there is some reason why must be a solution with a path within limit). However at least search algorithm guaranteed to terminate.
<h4>Iterative Deepening</h4>
Consists of repeated use of depth-limited depth-first search, where depth limit is increased (by one or more) each time until solution is found.
Combines benefits of breath and depth-first search:
- Modest memory requirements (same as depth-first)
- Complete when branching factor is finite
- Optimal when path cost is non-decreasing function of depth
Downside is that execution time likely to be large.
![[Pasted image 20250203133215.png]]
<h4>Uniform Cost Search</h4>
Variant of breadth-first search.

In standard BFS, always expanding nodes that are closest to initial state in terms of number of actions in their path. In Uniform Cost search we expand nodes that are closest to the initial state in terms of the **cost** of their path. Consequently, nodes on the fringe will have approximately equal costs.
If cost of all actions same, Uniform Cost search is equivalent to standard BFS. 
Uniform Cost search can be implemented by a queue that is ordered by means of the path cost function (lower cost first).
<h4> Direction Of Search</h4>
Thinking of search as progressing from initial state towards goal state.

However, sometimes better to search backwards, from goal state then look for states that can reach goal by one action.
Then proceed to look at states that can reach these states by one action, continue until (hopefully) we reach initial state.
Useful when backwards branching factor is lower than forwards branching factor. 
Backwards search difficult to implement if there are many goal states, or if state transitions are difficult to define in the reverse direction.
<h4>Bi-Directional Search</h4>
Strategy where search space is explored from both initial and goal state.

Solution found when forward and backwards search path meet at some state.